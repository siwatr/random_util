#!/usr/bin/env Rscript 

# Auto generated by GitHub Copilot:
#' Merge Overlapping Genomic Ranges
#'
#' This function merges overlapping genomic ranges and computes a summary score 
#' for the merged regions based on a specified operation.
#'
#' @param gr A `GRanges` object containing genomic ranges with a numeric score column.
#' @param base An integer indicating the base for the start position. Default is 1. 
#'             If set to 0, the start positions will be incremented by 1.
#' @param operation A character string specifying the operation to be applied to 
#'                  the scores of overlapping regions. Must be one of "mean", "sum", 
#'                  "median", "max", or "min". Default is "mean".
#' @param verbose A logical value indicating whether to print the number of overlapping 
#'                regions. Default is the result of `interactive()`.
#'
#' @return A `GRanges` object with merged non-overlapping regions and computed scores.
#'
#' @import dplyr
#' @import tidyr
#' @import magrittr
#' @import tibble
#' @import stringr
#' @import rtracklayer
#' @import GenomicRanges
#'
#' @examples
#' # Example usage:
#' library(GenomicRanges)
#' gr <- GRanges(seqnames = "chr1", ranges = IRanges(start = c(1, 5, 10), end = c(4, 8, 12)), score = c(5, 10, 15))
#' merged_gr <- merge_wig(gr, base = 1, operation = "mean", verbose = TRUE)
#' 
#' @export

merge_wig <- function(gr, base=1, operation="mean", verbose=interactive()){
  suppressPackageStartupMessages({
    require("dplyr")
    require("tidyr")
    require("magrittr")
    require("tibble")
    require("stringr")
    require("rtracklayer")
    require("GenomicRanges")
  })
  # Check input granges
  if (!is(gr, "GRanges")) {stop("gr must be a GRanges object")}
  if (!"score" %in% colnames(mcols(gr))) {stop("Cannot find score column")}
  if (!is.numeric(gr$score)) {stop("Score column must be numeric")}
  if (!operation %in% c("mean", "sum", "median", "max", "min")) {
    stop("Operation must be one of 'mean', 'sum', 'median', 'max', 'min'")
  }
  if(base == 0) {start(gr) <- start(gr) + 1}
  
  # Check for intra-range overlaps
  ovl <- findOverlaps(gr, gr)
  ovl <- ovl[queryHits(ovl) != subjectHits(ovl)]
  if(verbose) {cat("Number of overlapping regions: ", length(ovl), "\n")}
  if(length(ovl) == 0){
    return(gr)
  }
  
  # Overlap detected, merge the regions
  d_gr <- disjoin(gr) # making non-overlapping regions
  d_ovl <- findOverlaps(d_gr, gr)
  d_ovl_df <- as_tibble(d_ovl) %>%
    mutate(score = gr$score[subjectHits(d_ovl)])
  
  # Find duplicated queryHits
  d_dup_idx <- unique(queryHits(d_ovl)[duplicated(queryHits(d_ovl))])
  d_ovl_unq_df <- dplyr::filter(d_ovl_df, !queryHits %in% d_dup_idx)
  d_ovl_dup_df <- dplyr::filter(d_ovl_df, queryHits %in% d_dup_idx)
  # Compute score for duplicated regions
  d_ovl_dup_df <- d_ovl_dup_df %>%
    group_by(queryHits) %>%
    reframe(score = get(operation)(score))
  # Merge back and assign score to the disjoined GRanges
  d_ovl_df <- bind_rows(dplyr::select(d_ovl_unq_df, queryHits, score), d_ovl_dup_df)
  d_gr$score <- 0 # placeholder
  d_gr$score[d_ovl_df$queryHits] <- d_ovl_df$score
  return(d_gr)
}

# CLI =============================================================================================
if(!interactive() & sys.nframe()==0L){
  ## Not interactive and not being sourced from other function
  ## i.e., got run from command line interface.
  suppressPackageStartupMessages({
    library(argparser)
  })
  
  parser <- arg_parser("merge_wig.r | Merging intra-overlap regions within wig file (or other bed-like format with score field)")
  
  parser <- add_argument(parser,
    short = "-i", arg = "--input",
    help = "Paths to input file",
    type = "character", default = NULL, nargs = 1
  )
  
  parser <- add_argument(parser,
    short = "-b", arg = "--base",
    help = paste0("Start coordinate system indicater - either 0 or 1, or auto."),
    # Wig in general is 1-based
    type = "character", default = "1", nargs = 1
  )
  
  parser <- add_argument(parser,
    short = "-s", arg = "--score_col",
    help = paste0("Which column indicates the score value."),
    type = "numeric", default = 4, nargs = 1
  )
  parser <- add_argument(parser,
    short = "-o", arg = "--operation",
    help = "Operation to use when merging overlapping regions",
    type = "character", default = "mean", nargs = 1
  )
  
  parser <- add_argument(parser,
    short = "-O", arg = "--outfile",
    help = paste0("Path (preferably absolute) to an output file "),
    type = "character", default = ".", nargs = 1
  )
  
  parser <- add_argument(parser,
    short = "-g", arg = "--genome",
    help = paste0(
      "Short name of the genome (e.g., mm10, or hg19). ",
      "This option is only required when output file is in bigwig format. "
    ),
    # Wig in general is 1-based
    type = "character", default = NULL, nargs = 1
  )

  parser <- add_argument(parser,
    short = "-c", arg = "--chrome_size",
    help = paste0("Path to chromosome size (length) file. ",
                  "This option is only required when output file is in bigwig format. ",
                  "This option is an alternative to --genome option, and it has lower priority if both options are provided. "),
    # Wig in general is 1-based
    type = "character", default = NULL, nargs = 1
  )

  parser <- add_argument(parser,
    short = "-v", arg = "--verbose",
    help = "verbosity",
    flag = TRUE
  )
  # Assign value
  try(argv <- parse_args(parser))
  if (argv$verbose) {
    print(str(argv))
  }
  
  # Run the main function -------------------------------------------------------------------------
  suppressPackageStartupMessages({
    library("dplyr")
    library("tidyr")
    library("magrittr")
    library("tibble")
    library("stringr")
    library("rtracklayer")
    library("GenomicRanges")
  })

  # Check the base coordinate system
  argv$base <- tolower(argv$base)
  if (!argv$base %in% c("1", "2", "auto")) {
    stop("Base coordinate system must be either 0, 1, or auto")
  }

  
  if(verbose) {cat("Reading input file ... ")}
  df <- as_tibble(read.table(argv$input, sep = "\t", header = FALSE, stringsAsFactors = FALSE))
  colnames(df)[1:3] <- c("seqnames", "start", "end")
  colnames(df)[argv$score_col] <- "score"
  df <- dplyr::arrange(df, seqnames, start, end)
  if(verbose) {cat("Done\n")}
  
    # Guessing the base coordinate system
  if(argv$base == "auto"){
    pc_start_end_match <- sum(df$start[-1] == df$end[-nrow(df)]) / nrow(df) * 100
    if(any(df$start == 0)){
      base = "0"
    }else if(pc_start_end_match > 70){
      # If more than 70% of the start column matches the end of the previous region, then it is likely 0-based coordinate
      base = 0
    }else{
      base = 1
    }
  }else{
    base = as.numeric(argv$base)
  }
  
  if(any(df$start == 0) & argv$base == 1) {
    warning("Base coordinate system is 1, but found 0 in start column")
  }
  
  # Merge overlapping regions ---------------------------------------------------------------------
  if(verbose) {cat("Merging overlapping regions ... ")}
  gr <- makeGRangesFromDataFrame(df, keep.extra.columns = TRUE)
  gr_merge <- merge_wig(gr, base = argv$base, operation = argv$operation, verbose = argv$verbose)
  if (verbose) {
    cat("Done\n")
  }
  
  # Save output -----------------------------------------------------------------------------------
  if(verbose) {cat("Saving output file ... ")}
  out_ext <- tolower(tools::file_ext(argv$outfile))
  if (out_ext %in% c("bed", "bedgraph", "wig")) {
    export(gr_merge, argv$outfile, format = out_ext)

  }else if(out_ext == "bw"){
    # Seqlength (e.g., chrom size) is needed for bigwig output
    seq_len_df <- tibble()
    # Option 1) Retrieve from the database
    if(!is.na(argv$genome)){
      # Retrieve a list of possible genome names
      organism_df = GenomeInfoDb::listOrganisms()
      suppressWarnings({
        avail_genome <- sapply(organism_df$commonName, function(x) {
          GenomeInfoDb::genomeBuilds(organism = x)[["ucscID"]]
        }) %>% do.call(c, .)
      })
      if (argv$genome %in% avail_genome) {
        # Retrieve chrom size information
        seq_len_obj <- GenomeInfoDb::Seqinfo(genome = argv$genome)
        seq_len_df <- as.data.frame(seq_len_obj) %>% 
          tibble::rownames_to_column(var="seqnames")
        # seqinfo(gr_merge) <- seq_len_obj
      }else{
        warning("Cannot find genome information for ", argv$genome)
      }
    }
    # Option 2) Try retrieve seq_len_df from chrom_size file
    if (nrow(seq_len_df) == 0) {
      # i.e., genome information is not provided
      if (is.na(argv$chrome_size)) {
        stop("Chromosome length file is required for bigwig output")
      }
      # based on mm10 chrom size file: we don't expect header
      seq_len_df <- read.table(argv$chrome_size, sep = "\t", header = FALSE, stringsAsFactors = FALSE)
    }
    colnames(seq_len_df)[1:2] <- c("seqnames", "seqlengths")
    seq_len_df <- dplyr::filter(seq_len_df, seqnames %in% names(seqlengths(gr_merge)))
    seqlengths(gr_merge) <- dplyr::pull(seq_len_df, seqlengths, name = seqnames)[names(seqlengths(gr_merge))] # make sure the order is correct
    export.bw(gr_merge, argv$outfile)

  }else if(out_ext == "txt"){
    write.table(as.data.frame(gr_merge), argv$outfile, sep = "\t", row.names = FALSE, col.names = TRUE, quote=FALSE)
  }else{
    stop("Output file format '", out_ext, "' is not supported")
  }
  if(verbose) {cat("Done\n")}
}

# Test ============================================================================================

if(FALSE){
  wd = "/fs/pool/pool-toti-bioinfo/DATA_NGS/public_dataset/CutTag_TIPseq/GSE218379_Nr5a2_CnR_2023/GEO/mm10_liftOver/wig"
  # From UCSC website: The bedGraph format, like all BED-based formats and most file formats used by UCSC, use "0-start, half-open" coordinates, but the wiggle ASCII text format for variableStep and fixedStep data uses "1-start, fully-closed" coordinates. Wiggle (variableStep and fixedStep) is the only format defined by UCSC that uses a 1-based format, for historical reasons. For example, for a chromosome of length N, the first position is 1 and the last position is N
  # Note on coordinate system:
  #    wig file is 1-based,
  #    bed file is 0-based
  #    genomicRanges is 1-based

  bw_f = "/fs/pool/pool-toti-bioinfo/DATA_NGS/public_dataset/CutTag_TIPseq/GSE218379_Nr5a2_CnR_2023/GEO/mm9_original/GSM7922950_2C_Nr5a2_NC_ATAC_rep1.bw"
  gr_bw = BiocIO::import(bw_f)
  f = "/fs/pool/pool-toti-bioinfo/DATA_NGS/public_dataset/CutTag_TIPseq/GSE218379_Nr5a2_CnR_2023/GEO/mm9_original/wig/GSM7922950_2C_Nr5a2_NC_ATAC_rep1.wig"
  f = paste0(wd, "/GSM7922950_2C_Nr5a2_NC_ATAC_rep1_filter_sorted.wig")
  df <- as_tibble(read.table(f, sep = "\t", header=FALSE, stringsAsFactors = FALSE))
  colnames(df) <- c("seqnames", "start", "end", "score")

  # problem with reduce() function: it will also combining regions that are next to each other, though they are not overlapping.

  gr <- makeGRangesFromDataFrame(df, keep.extra.columns = TRUE)
  gr[seqnames(gr) == "chrM"]
  # gr_red <- reduce(gr)

  # Testing out some intra-range-methods operations:
  # disjoin
  test_gr <- GRanges(
    seqnames = c("chr1"),
    ranges = IRanges(start = c(1,   50,  150, 201), 
                    end =    c(100, 150, 200, 300)), 
                    score =  c(1, 2, 3)
  )
  disjoin(test_gr)
  coverage(gr)
}
